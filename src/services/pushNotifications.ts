//Core React Native modules
import { Platform } from "react-native";

//3rd Party Libraries
const PushNotification = require("react-native-push-notification");
import PushNotificationIOS from "@react-native-community/push-notification-ios";
import moment from "moment";

//Utilities
import { theWeekNumericalValues } from "../utilities/theWeekNumericalValues";
import { getTask } from "../controllers/database/Tasks/getTask";
import {
  getAllUncheckedTaskIdsForASingleDay,
  getAllTaskIdsForASingleDay,
  getAllCheckedTaskIdsForASingleDay,
} from "../controllers/database/Tasks/tasks";
import theWeek from "../utilities/theWeek";
import reminderTimes from "../utilities/reminderTimes";

const configure = async () => {
  PushNotification.configure({
    onRegister: function (token) {
      //process token
    },

    onNotification: function (notification) {
      console.log("NOTIFICATION:", notification);
      // process the notification
      // required on iOS only
      notification.finish(PushNotificationIOS.FetchResult.NoData);
    },

    permissions: {
      alert: true,
      badge: true,
      sound: true,
    },

    popInitialNotification: true,
    requestPermissions: Platform.OS === "ios",
  });
};

const testLocalNotifications = () => {
  PushNotification.localNotification({
    title: "Title Test",
    message: "Message Test",
  });
  return null;
};

const addARepeatingLocalNotification = async (
  taskId: number,
  delay: number = 0
) => {
  let task = await getTask(taskId);
  console.log(task);
  let currentDayComparator = moment().isoWeekday();
  let taskDayComparator = theWeekNumericalValues[task.day];

  if (currentDayComparator > taskDayComparator) {
    PushNotification.localNotificationSchedule({
      /* Android Only Properties */
      id: task.id.toString(), // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
      ticker: "My Notification Ticker", // (optional)
      showWhen: true, // (optional) default: true
      autoCancel: true, // (optional) default: true
      largeIcon: "ic_launcher", // (optional) default: "ic_launcher"
      largeIconUrl: undefined, // (optional) default: undefined
      smallIcon: "ic_notification", // (optional) default: "ic_notification" with fallback for "ic_launcher"
      bigText: task.text, // (optional) default: "message" prop
      subText: "", // (optional) default: none
      bigPictureUrl: undefined, // (optional) default: undefined
      color: "red", // (optional) default: system default
      vibrate: true, // (optional) default: true
      vibration: 300, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
      ongoing: false, // (optional) set whether this is an "ongoing" notification
      priority: "high", // (optional) set notification priority, default: high
      visibility: "private", // (optional) set notification visibility, default: private
      importance: "high", // (optional) set notification importance, default: high
      allowWhileIdle: true, // (optional) set notification to work while on doze, default: false
      ignoreInForeground: false, // (optional) if true, the notification will not be visible when the app is in the foreground (useful for parity with how iOS notifications appear)
      onlyAlertOnce: false, //(optional) alert will open only once with sound and notify, default: false
      actions: '["Yes", "No"]', // (Android only) See the doc for notification actions to know more
      invokeApp: true, // (optional) This enable click on actions to bring back the application to foreground or stay in background, default: true

      /* iOS only properties */
      alertAction: "view", // (optional) default: view
      category: "", // (optional) default: empty string
      userInfo: {}, // (optional) default: {} (using null throws a JSON value '<null>' error)

      /* iOS and Android properties */
      title: task.day + " Task", // (optional)
      message: task.text, // (required)
      date: moment()
        .startOf("week")
        .add(1, "week")
        .add(taskDayComparator - 1, "days")
        .add(task.reminderTimeValue, "hours")
        .toDate(), // (required)
      playSound: true, // (optional) default: true
      soundName: "default", // (optional) Sound to play when the notification is shown. Value of 'default' plays the default sound. It can be set to a custom sound such as 'android.resource://com.xyz/raw/my_sound'. It will look for the 'my_sound' audio file in 'res/raw' directory and play it. default: 'default' (default sound is played)
      repeatType: "week", // (optional) Repeating interval. Check 'Repeating Notifications' section for more info.
    });
  } else if (currentDayComparator <= taskDayComparator) {
    PushNotification.localNotificationSchedule({
      /* Android Only Properties */
      id: task.id.toString(), // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
      ticker: "My Notification Ticker", // (optional)
      showWhen: true, // (optional) default: true
      autoCancel: true, // (optional) default: true
      largeIcon: "ic_launcher", // (optional) default: "ic_launcher"
      largeIconUrl: undefined, // (optional) default: undefined
      smallIcon: "ic_notification", // (optional) default: "ic_notification" with fallback for "ic_launcher"
      bigText: task.text, // (optional) default: "message" prop
      subText: "", // (optional) default: none
      bigPictureUrl: undefined, // (optional) default: undefined
      color: "red", // (optional) default: system default
      vibrate: true, // (optional) default: true
      vibration: 300, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
      ongoing: false, // (optional) set whether this is an "ongoing" notification
      priority: "high", // (optional) set notification priority, default: high
      visibility: "private", // (optional) set notification visibility, default: private
      importance: "high", // (optional) set notification importance, default: high
      allowWhileIdle: true, // (optional) set notification to work while on doze, default: false
      ignoreInForeground: false, // (optional) if true, the notification will not be visible when the app is in the foreground (useful for parity with how iOS notifications appear)
      onlyAlertOnce: false, //(optional) alert will open only once with sound and notify, default: false
      actions: '["Yes", "No"]', // (Android only) See the doc for notification actions to know more
      invokeApp: true, // (optional) This enable click on actions to bring back the application to foreground or stay in background, default: true

      /* iOS only properties */
      alertAction: "view", // (optional) default: view
      category: "", // (optional) default: empty string
      userInfo: {}, // (optional) default: {} (using null throws a JSON value '<null>' error)

      /* iOS and Android properties */
      title: task.day + " Task", // (optional)
      message: task.text, // (required)
      date: moment()
        .startOf("isoWeek")
        .add(delay, "week")
        .add(taskDayComparator - 1, "days")
        .add(task.reminderTimeValue, "hours")
        .toDate(), // (required)
      playSound: true, // (optional) default: true
      soundName: "default", // (optional) Sound to play when the notification is shown. Value of 'default' plays the default sound. It can be set to a custom sound such as 'android.resource://com.xyz/raw/my_sound'. It will look for the 'my_sound' audio file in 'res/raw' directory and play it. default: 'default' (default sound is played)
      repeatType: "week", // (optional) Repeating interval. Check 'Repeating Notifications' section for more info.
    });
  }
  return null;
};

const checkingATaskNotification = async (taskId: number, delay: number) => {
  await removeALocalScheduledNotification(taskId);
  await addARepeatingLocalNotification(taskId, delay);
  return null;
};

const unCheckingATaskNotification = async (taskId: number) => {
  await removeALocalScheduledNotification(taskId);
  await addARepeatingLocalNotification(taskId);
  return null;
};

const removeALocalScheduledNotification = async (taskId: number) => {
  PushNotification.cancelLocalNotifications({ id: taskId.toString() });
  return null;
};

const removeAllLocalNotifications = () => {
  PushNotificationIOS.removeAllDeliveredNotifications();
  PushNotification.cancelAllLocalNotifications();
  return null;
};

const createDailyRepeatingNotification = async (
  reminderTime: string,
  id: number = 1000000
) => {
  //Remove past notifications before adding/recreating new ones
  await removeDailyRepeatingNotification();

  let currentDay = moment().format("dddd");
  let currentIndexBasedOfDay = theWeek.indexOf(currentDay);

  //Notifications for today and onwards until the end of the week
  for (let i = currentIndexBasedOfDay; i < theWeek.length; i++) {
    let taskIdsForADay = await getAllUncheckedTaskIdsForASingleDay(theWeek[i]);

    PushNotification.localNotificationSchedule({
      /* Android Only Properties */
      id: (id + i).toString(), // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
      ticker: "My Notification Ticker", // (optional)
      showWhen: true, // (optional) default: true
      autoCancel: true, // (optional) default: true
      largeIcon: "ic_launcher", // (optional) default: "ic_launcher"
      largeIconUrl: undefined, // (optional) default: undefined
      smallIcon: "ic_notification", // (optional) default: "ic_notification" with fallback for "ic_launcher"
      bigText: `You have ${taskIdsForADay.length} tasks remaining today.`, // (optional) default: "message" prop
      subText: "", // (optional) default: none
      bigPictureUrl: undefined, // (optional) default: undefined
      color: "red", // (optional) default: system default
      vibrate: true, // (optional) default: true
      vibration: 300, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
      ongoing: false, // (optional) set whether this is an "ongoing" notification
      priority: "high", // (optional) set notification priority, default: high
      visibility: "private", // (optional) set notification visibility, default: private
      importance: "high", // (optional) set notification importance, default: high
      allowWhileIdle: true, // (optional) set notification to work while on doze, default: false
      ignoreInForeground: false, // (optional) if true, the notification will not be visible when the app is in the foreground (useful for parity with how iOS notifications appear)
      onlyAlertOnce: false, //(optional) alert will open only once with sound and notify, default: false
      actions: '["Yes", "No"]', // (Android only) See the doc for notification actions to know more
      invokeApp: true, // (optional) This enable click on actions to bring back the application to foreground or stay in background, default: true

      /* iOS only properties */
      alertAction: "view", // (optional) default: view
      category: "", // (optional) default: empty string
      userInfo: {}, // (optional) default: {} (using null throws a JSON value '<null>' error)

      /* iOS and Android properties */
      title: `${theWeek[i]}'s Tasks`, // (optional)
      message: `You have ${taskIdsForADay.length} tasks remaining today.`, // (required)
      date: moment()
        .startOf("isoWeek")
        .add(i, "days")
        .add(reminderTimes[reminderTime], "hours")
        .toDate(), // (required)
      playSound: true, // (optional) default: true
      soundName: "default", // (optional) Sound to play when the notification is shown. Value of 'default' plays the default sound. It can be set to a custom sound such as 'android.resource://com.xyz/raw/my_sound'. It will look for the 'my_sound' audio file in 'res/raw' directory and play it. default: 'default' (default sound is played)
      repeatType: "day", // (optional) Repeating interval. Check 'Repeating Notifications' section for more info.
    });
  }

  //Notifications prior to today, starting at the start of the week
  for (let i = 0; i < currentIndexBasedOfDay; i++) {
    let taskIdsForADay = await getAllUncheckedTaskIdsForASingleDay(theWeek[i]);

    PushNotification.localNotificationSchedule({
      /* Android Only Properties */
      id: (id + i).toString(), // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
      ticker: "My Notification Ticker", // (optional)
      showWhen: true, // (optional) default: true
      autoCancel: true, // (optional) default: true
      largeIcon: "ic_launcher", // (optional) default: "ic_launcher"
      largeIconUrl: undefined, // (optional) default: undefined
      smallIcon: "ic_notification", // (optional) default: "ic_notification" with fallback for "ic_launcher"
      bigText: `You have ${taskIdsForADay.length} tasks remaining today.`, // (optional) default: "message" prop
      subText: "", // (optional) default: none
      bigPictureUrl: undefined, // (optional) default: undefined
      color: "red", // (optional) default: system default
      vibrate: true, // (optional) default: true
      vibration: 300, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
      ongoing: false, // (optional) set whether this is an "ongoing" notification
      priority: "high", // (optional) set notification priority, default: high
      visibility: "private", // (optional) set notification visibility, default: private
      importance: "high", // (optional) set notification importance, default: high
      allowWhileIdle: true, // (optional) set notification to work while on doze, default: false
      ignoreInForeground: false, // (optional) if true, the notification will not be visible when the app is in the foreground (useful for parity with how iOS notifications appear)
      onlyAlertOnce: false, //(optional) alert will open only once with sound and notify, default: false
      actions: '["Yes", "No"]', // (Android only) See the doc for notification actions to know more
      invokeApp: true, // (optional) This enable click on actions to bring back the application to foreground or stay in background, default: true

      /* iOS only properties */
      alertAction: "view", // (optional) default: view
      category: "", // (optional) default: empty string
      userInfo: {}, // (optional) default: {} (using null throws a JSON value '<null>' error)

      /* iOS and Android properties */
      title: `${theWeek[i]}'s Tasks`, // (optional)
      message: `You have ${taskIdsForADay.length} tasks remaining today.`, // (required)
      date: moment()
        .startOf("isoWeek")
        .add(1, "weeks")
        .add(i, "days")
        .add(reminderTimes[reminderTime], "hours")
        .toDate(), // (required)
      playSound: true, // (optional) default: true
      soundName: "default", // (optional) Sound to play when the notification is shown. Value of 'default' plays the default sound. It can be set to a custom sound such as 'android.resource://com.xyz/raw/my_sound'. It will look for the 'my_sound' audio file in 'res/raw' directory and play it. default: 'default' (default sound is played)
      repeatType: "day", // (optional) Repeating interval. Check 'Repeating Notifications' section for more info.
    });
  }
};

const removeDailyRepeatingNotification = async () => {
  //Completely depends on the IDs supplied for the createDailyRepeatingNotification function
  try {
    for (let i = 1000000; i < 1000007; i++) {
      PushNotification.cancelLocalNotifications({ id: i.toString() });
    }
  } catch (err) {
    console.log(err);
  }
};

const removingAllTasksNotifications = async () => {
  for (let day of theWeek) {
    let taskIdArray = await getAllTaskIdsForASingleDay(day);
    await taskIdArray.forEach(async (taskId: number) => {
      await removeALocalScheduledNotification(taskId);
    });
  }
};

const addingAllTasksNotifications = async () => {
  const currentDay = moment().format("dddd");
  const currentIndexBasedOffDay = theWeek.indexOf(currentDay);

  for (let i = currentIndexBasedOffDay; i < theWeek.length; i++) {
    let uncheckedTaskIdsArray = await getAllUncheckedTaskIdsForASingleDay(
      theWeek[i]
    );
    let checkedTaskIdsArray = await getAllCheckedTaskIdsForASingleDay(
      theWeek[i]
    );

    uncheckedTaskIdsArray.forEach(async (taskId: number) => {
      await addARepeatingLocalNotification(taskId);
    });

    checkedTaskIdsArray.forEach(async (taskId: number) => {
      await addARepeatingLocalNotification(taskId, 1);
    });
  }

  for (let i = 0; i < currentIndexBasedOffDay; i++) {
    let taskIdsArray = await getAllTaskIdsForASingleDay(theWeek[i]);
    taskIdsArray.forEach(async (taskId: number) => {
      await addARepeatingLocalNotification(taskId, 1);
    });
  }
};

const setApplicationIconBadgeNumber = (number: number) => {
  PushNotification.setApplicationIconBadgeNumber(number);
  return null;
};

export {
  configure,
  testLocalNotifications,
  addARepeatingLocalNotification,
  checkingATaskNotification,
  unCheckingATaskNotification,
  removeALocalScheduledNotification,
  removeAllLocalNotifications,
  setApplicationIconBadgeNumber,
  createDailyRepeatingNotification,
  removeDailyRepeatingNotification,
  removingAllTasksNotifications,
  addingAllTasksNotifications,
};
